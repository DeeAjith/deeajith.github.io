<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Webgl Bogie!</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <ul>
        <li class="active"><a href="index.html">Assesmbled View</a></li>
        <li><a href="dis.html">Disassembled View</a></li>
        <li><a href="index2.html">Module 4test</a></li>
    </ul>
    <progress max="100" value="0"></progress>

    <div class="canv">
        <canvas id="myCanvas"></canvas>
    </div>

    <script src="js/three.js"></script>
    <script src="js/threex.domevents.js"></script>
    <script src="js/LightShadow.js"></script>
    <!-- <script src="threex-v0-master/threex.domevent.object3d.js"></script> -->
    <script src="js/OrbitControls.js"></script>
    <script src="/js/Raycaster.js"></script>
    <script src="js/CSS2DRenderer.js"></script>
    <script src="js/GLTFLoader.js"></script>
    <!-- <script src="js/mainAss.js"></script> -->
    <script>
        var renderer,
            scene, bog,
            camera,
            myCanvas = document.getElementById('myCanvas');
        var SHADOW_MAP_WIDTH = 2048,
            SHADOW_MAP_HEIGHT = 2048;

        {

            //RENDERER
            renderer = new THREE.WebGLRenderer({
                canvas: myCanvas,
                antialias: true
            });
            renderer.info.reset();
            // renderer.setClearColor(0x2a2a2a);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; //Shadow
            renderer.shadowMapSoft = true; // Shadow
            renderer.shadowMap.type = THREE.PCFShadowMap;
            renderer.gammaInput = true;
            renderer.gammaOutput = true;
            renderer.gammaFactor = 1;
            document.body.appendChild(renderer.domElement);
            var raycaster = new THREE.Raycaster(); // Needed for object intersection
            var mouse = new THREE.Vector2(); //Needed for mouse coordinates
            //CAMERA
            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
            var controls = new THREE.OrbitControls(camera);
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.LEFT,
                MIDDLE: THREE.MOUSE.MIDDLE,
                RIGHT: THREE.MOUSE.RIGHT
            }
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.enableDamping = true;
            controls.dampingFactor = 0.12;
            controls.rotateSpeed = 0.08;
            controls.maxPolarAngle = Math.PI / 2;
            // //controls.update() must be called after any manual changes to the camera's transform
            camera.position.set(1.7, 1.2, 1.5);

            //SCENE
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);
            scene.fog = new THREE.Fog(0x59472b, 1, 10);

            //LIGHTS

            var skyColor = 0xB1E1FF; // light blue
            var groundColor = 0xB97A20; // brownish orange
            var intensity = 1;
            var light1 = new THREE.HemisphereLight(skyColor, groundColor, intensity);
            scene.add(light1);


            var color = 0xFFFFFF;
            var intensity = 1;
            var light2 = new THREE.DirectionalLight(color, intensity);
            light2.position.set(5, 10, 2);
            light2.shadow.mapSize.width = 2048; // default
            light2.shadow.mapSize.height = 2048; // default
            light2.shadow.camera.near = 0.5; // default
            light2.shadow.camera.far = 500 // default
            light2.castShadow = true;
            light2.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(35, window.innerWidth / window
                .innerHeight, 0.1, 1000));
            light2.shadow.bias = -0.0001;
            light2.shadow.mapSize.width = SHADOW_MAP_WIDTH;
            light2.shadow.mapSize.height = SHADOW_MAP_HEIGHT;
            scene.add(light2);
            // scene.add(light.target);

            var dom = new THREEx.DomEvents(camera, renderer.domElement);

            var mss = (window.innerWidth / window.innerHeight) * .5;
            console.log(mss); //console check

            var col = 16;
            var loader = new THREE.GLTFLoader();
            loader.load('/asse.gltf',
                function handle_load(gltf) {
                    console.log(gltf);
                    bog = gltf.scene;
                    gltf.scene.traverse(function (node) {

                        if (node instanceof THREE.Mesh) {
                            node.castShadow = true;
                        }

                    });
                    scene.add(bog);
                });
            var geom = new THREE.CubeGeometry(5, 5, .01);
            var mat = new THREE.ShadowMaterial({

                side: THREE.DoubleSide
            });

            var cube = new THREE.Mesh(geom, mat);
            cube.receiveShadow = true;
            scene.add(cube);
            cube.rotateX(-Math.PI / 2);
            //windows resize
            window.addEventListener('resize', onWindowResize, false);
        }
        // dom.addEventListener(bog, 'click', onClk, false);

        // function onClk() {
        //     console.log('you clicked on mesh', cube)
        // }
        // animate();
        render();
        animate();

        function onWindowResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = (window.innerWidth / window.innerHeight);
            camera.updateProjectionMatrix();

        }



        function render() {
            console.clear();
            renderer.render(scene, camera);

        }
        window.addEventListener('click', onDocumentMouseDown, false);
        render();

        function onDocumentMouseDown(event) {

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects([bog.children[col]]);

            if (intersects.length > 0) {
                intersects[0].object.material.color.setHex(Math.random() * 0xffffcc);
            }
        }


        function animate() {

            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>

</body>

</html>